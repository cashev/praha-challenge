# 課題01

## 質問

### 認証と認可、全般

#### 違い

- 認証 (Authentication)  
  利用者が誰であるかを特定し、確認すること  
  例えば、ユーザーが正しいパスワードを入力しているかどうかを確認すること
  - 方法  
    - パスワード
    - トークン
    - 生体認証
- 認可 (Authorization)  
  利用者が特定のリソースや情報にアクセスする権限を持っているかどうかを確認すること  
  認証の後に行われる。  
  例えば、ユーザーが管理者権限を持っているかどうかを確認すること
  - 方法  
    - Role-Based Access Control (RBAC)  
      ユーザーにロールを割り当て、そのロールに基づいてアクセス権を決定する。
    - Attribute-Based Access Control (ABAC)  
      ユーザーの属性に基づいてアクセス権を決定する。  
    - Policy-Based Access Control (PBAC)  
      ポリシーに基づいてアクセス権を決定する。

- 参考
  - [Microsoft Authentication vs. authorization](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-vs-authorization)
  - [Okta Authentication vs. Authorization](https://www.okta.com/identity-101/authentication-vs-authorization/)

#### 認証の仕組みではない

OAuth2.0は認証ではなく、認可の仕組みであるため。  

OAuth2.0はウェブサイトやアプリケーションが、  
ユーザーの代わりにリソースにアクセスするための権限を取得するためのフレームワークである。  

- 参考
  - [OAuth 2.0とは？](https://auth0.com/jp/intro-to-iam/what-is-oauth-2)

### OAuth2.0

#### Authorization grant types

- Authorization Code  
  認可サーバーを用いて、認可コード, アクセストークンを発行しリソースにアクセスする。  
  最もセキュアなグラントタイプで、主にサーバーサイドアプリケーションで使用される。  
  - フロー  
    1. クライアントがユーザーを認可サーバーにリダイレクトする。  
    2. ユーザーが認可サーバーにログインし、クライアントがリソースにアクセスする許可を与える。  
    3. 認可サーバーがユーザーをクライアントにリダイレクトし、認可コードを提供する。  
    4. クライアントが認可コードを使って認可サーバーからアクセストークンを取得する。  
    5. クライアントがアクセストークンを使ってリソースサーバーからリソースを取得する。
    6. リソースサーバーがアクセストークンを認可サーバーで検証する。  
    7. リソースサーバーがリソースをクライアントに提供する。  
  - メリット
    - セキュリティが高い。  
      アクセストークンはクライアントサーバーとリソースサーバー間でのみ使用され、  
      ブラウザには渡されないため、セキュリティが高い。
    - リフレッシュトークンを使ってアクセストークンを更新できる。  
      アクセストークンの有効期限が切れた場合、リフレッシュトークンを使ってアクセストークンを更新できる。  
      ユーザーが再度ログインする必要がないため、UXが向上する。  
  - デメリット
    - 認可フローが複雑  
      認可フローが複雑であるため、実装が難しい。  
    - 通信が多い  
      認可コードとアクセストークンを取得するため複数のリクエストが必要である。
- Implicit  
  認可コードを使用せず、認可サーバーからアクセストークンを直接取得する。  
  シングルページアプリケーションやモバイルアプリケーションで使用される。  
  セキュアではないため、最近は推奨されていない。
  - フロー  
    1. クライアントがユーザーを認可サーバーにリダイレクトする。
    2. ユーザーが認可サーバーにログインし、クライアントがリソースにアクセスする許可を与える。
    3. 認可サーバーがユーザーをクライアントにリダイレクトし、アクセストークンを提供する。
    4. クライアントがアクセストークンを使ってリソースサーバーからリソースを取得する。
    5. リソースサーバーがアクセストークンを認可サーバーで検証する。
    6. リソースサーバーがリソースをクライアントに提供する。
  - メリット
    - 認可フローがシンプル  
      認可フローがシンプルであるため、実装が容易。
  - デメリット
    - セキュリティが低い  
      アクセストークンがブラウザに渡されるため、セキュリティが低い。
    - リフレッシュトークンを利用できない  
      アクセストークンの有効期限が切れた場合、リフレッシュトークンを使ってアクセストークンを更新できない。  
      ユーザーが再度ログインする必要があるため、UXが低下する。
- Resource Owner Password Credentials  
  ユーザーがクライアントに直接認証情報（ユーザー名とパスワード）を提供し、アクセストークンを取得する。
  - フロー  
    1. ユーザーがクライアントに直接認証情報を提供する。
    2. クライアントが認証情報を使って認可サーバーからアクセストークンを取得する。
    3. クライアントがアクセストークンを使ってリソースサーバーからリソースを取得する。
    4. リソースサーバーがアクセストークンを認可サーバーで検証する。
    5. リソースサーバーがリソースをクライアントに提供する。
  - メリット
    - 認可フローがシンプル  
      ユーザーが直接認証情報を提供するため、認可フローがシンプル。
    - アクセストークンをブラウザに渡さない  
      アクセストークンがブラウザに渡されないため、セキュリティが高い。
  - デメリット
    - セキュリティリスクがある  
      ユーザーが直接認証情報を提供するため、セキュリティリスクがある。
    - 信頼性が必要  
      クライアントがユーザーの認証情報を信頼する必要がある。
- Client Credentials  
  クライアントが自身の認証情報を使ってアクセストークンを取得する。
  - フロー
    1. クライアントが自身の認証情報を使って認可サーバーからアクセストークンを取得する。
    2. クライアントがアクセストークンを使ってリソースサーバーからリソースを取得する。
    3. リソースサーバーがアクセストークンを認可サーバーで検証する。
    4. リソースサーバーがリソースをクライアントに提供する。
  - メリット  
    - 認可フローがシンプル  
      ユーザーの介入がないため、認可フローがシンプル。
  - デメリット
    - ユーザーを特定できない  
      ユーザーを特定できないため、ユーザーの操作を追跡できない。
    - 利用ケースが限られる  
      ユーザーに関連するリソースにアクセスする場合には利用できない。

- 参考
  - [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
  - [OAuth 2 Simplified #Authorization](https://aaronparecki.com/oauth-2-simplified/#authorization)
  - [OAuth 2.0 全フローの図解と動画](https://qiita.com/TakahikoKawasaki/items/200951e5b5929f840a1f)

#### OAuth2.0の図解

![OAuth2.0.drawio.png](./drawio/OAuth2.0.drawio.png)

- 参考
  - [OAuth 2.0 認可コードグラントフローについて理解したことをまとめます](https://moneyforward-dev.jp/entry/2022/12/01/authorization-code-grant-flow/)

### Twitter

### Open ID Connect

#### Open ID Connectの図解

#### メリット
