# 課題01

## SOLID原則の各要素

### 単一責任の原則 (single-responsibility principle)

1つのクラスに1つの責務を持たせること  
1クラスでさまざまな処理をさせない  
DBにアクセスする処理とファイルに書き込む処理を1つのクラスで行わない
しかし分割しすぎに注意  

### 開放閉鎖の原則（open/closed principle）

拡張に対しては開かれ、修正に対しては閉じられているべき  
既存の処理に対して安全に変更を加えるために、  
仕様追加があった場合はモジュールを追加することで振る舞いが追加でき、  
仕様変更があった場合はそのモジュールだけの変更で済むようすべき  

### リスコフの置換原則（Liskov substitution principle）

子クラスは親クラスの仕様に従わなければならない  
親クラスと同じように子クラスの処理を呼び出した場合、呼び出した側は親クラスのように使いたいため  
子クラスだけ別のバリデーション(チェック処理)を追加するのは、この原則に反するためNG

### インターフェース分離の原則 (Interface segregation principle)

汎用的なインターフェースより各用途に特化したインターフェースが多くあるべき  
様々なメソッドを持つ大きなインターフェースより、限られたメソッドを持つインターフェースが複数あるべき  
小さなインターフェースに区切ることで意図していない呼び出しを防ぐ  
別実体クラスへの交換が簡単になる  

### 依存性逆転の原則（dependency inversion principle）

実体クラスに依存するのではなく、抽象クラスに依存すべき  
変化しやすい具象クラスに依存せず、安定した抽象クラスに依存することで変更容易につながる

## 単一責任の原則とファイル分割の違い

ファイル分割だけだと特定の処理がそのファイルにまとまるだけのため  
単一責任が担保されておらず変更容易とはなりにくい  

## Open-Closed-Principleの実例

FizzBuzzの場合、  
3の倍数のときFizz, 5の倍数のときBuzzに変換するという2つのモジュールへ(15の倍数の時は2つのモジュールが適応される)  
7の倍数のときfoo という仕様追加はこのモジュールを追加で対応  
5の倍数のときbar という仕様変更は5の倍数のときのモジュールを変更する  

## リスコフの置換原則に違反した場合の不都合

インターフェースとその子クラスを意識したコード(if文など)が呼び出し側に散りばめられる  

```ts
if (reader instanceof AbcReader) {
    // AbcReaderクラスだけ別メソッドを使う
    reader.readAbc();
} else {
    reader.read();
}
```

## インターフェースのメリット

- 呼び出し側から無関係なメソッドが見えなくなり、使い方が簡単になる
- 呼び出されるメソッドを限定できて、問題分析しやすくなる
- 別のクラスで代替するとき、使っているインターフェースのメソッドだけ満たせば済む

## 依存性の逆転を用いるタイミング

プログラムの重要な処理が、あまり重要ではない処理に依存しているとき  
密結合なプログラムをテストできるような疎結合なプログラムに変更するとき

## デメトルの法則とは

### メリット

### コードの保守性に対して効果が無いこと

### デメテルの法則を守ることにはどのような意味/効果

## 参考

<https://ja.wikipedia.org/wiki/SOLID>
<https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87>
<https://gihyo.jp/dp/ebook/2022/978-4-297-13235-4>
