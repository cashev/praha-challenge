# トランザクション

## 課題01

### デッドロックの説明

複数のトランザクションが互いのロック解除を待つ状態になり、  
処理が進められなくなること  

例: トランザクションX, Yが資源A, Bをそれぞれロックする場合  

1. トランザクションXが資源Aをロックする
1. トランザクションYが資源Bをロックする
1. トランザクションXが資源Bを確保しようと待機する
1. トランザクションYが資源Aを確保しようと待機する
1. デッドロック発生

### デッドロックの事例

[原因はデッドロック、データが滞留して停止--JALシステム障害](https://japan.zdnet.com/article/35080846/)

#### 原因

処理Aがキャッシュを、処理Bがディスクをそれぞれロックし、  
互いにロック解除を待機する状態になってしまったため。  

#### 解決方法

ロックに制限時間を設け、制限時間を過ぎたらロック解除、
少し時間をおいてから再度実行するよう変更する。

### ISOLATION LEVELの説明, 差分, 問題

全ての処理を直列で実行すればデータの整合性を保つことができるが、トランザクションごとにロックが発生し遅くなってしまう。  
そのため、トランザクションの相互干渉を許容し、同時並行で処理することでパフォーマンスを向上させる。
どの程度トランザクションを分離するか4つのレベルに分けられる。  

トランザクションの相互干渉によって
Dirty read, Fuzzy read, Phantom readが発生し得る。  

#### Read Uncommitted

未コミットのデータであっても読み込む。
Dirty read, Fuzzy read, Phantom readが発生し得る。  

#### Read Committed

コミット済みのデータを読み込む。
Dirty readは防ぐ、Fuzzy read, Phantom readが発生し得る。  

#### Repetable Read

トランザクション中は別トランザクションでコミットされたデータを読み込まない。  
トランザクション中に読み込んだデータが常に一致することを保証する。  
Dirty read, Fuzzy readは防ぐ、Phantom readが発生し得る。  

#### Serializable

トランザクションの相互干渉は起きず、処理を直列に実行する。　　
Dirty read, Fuzzy read, Phantom readを防ぐ。  

#### 差分

| ISOLATION LEVEL | Dirty Read | Fuzzy read | Phantom Read |
| -- | -- | -- | -- |
| Read Uncommitted | Y | Y | Y |
| Read Committed | N | Y | Y |
| Repetable Read | N | N | Y |
| Serializable | N | N | N |

### 行ロック, テーブルロックの違い

行ロック... 行単位でロックを行う。1行の場合や複数行の場合もある。  
テーブルロック... 対象とするレコードのテーブル全体をロックする。  

### 悲観ロック, 楽観ロックの違い

#### 悲観ロック

トランザクション開始から終了までロックを取得し、  
別トランザクションからの参照、更新を行わせない。  
処理中に頻繁に更新が発生する場合、有効。  
デッドロックが発生しないよう注意して設計する必要がある。  

#### 楽観ロック  

カラムにバージョン情報を追加し、レコードを読み取るときに合わせて取得する。  
レコードの更新時に再度バージョンを取得し、レコードが更新されていないか確認してから更新を行う。  
実装は悲観ロックより容易だが、頻繁に更新が発生する場合はデータが汚れる可能性がある。  

### 共有ロック, 排他ロックの違い

#### 共有ロック  

別トランザクションからの更新は許可しないが、参照は許可する。  

#### 排他ロック

別トランザクションからの更新、参照を許可しない。  

### fuzzy-read, phantom-readの違い  

#### fuzzy-read  

トランザクション開始時に読み込んだ内容と、  
別トランザクションでコミット後に再度読み込んだ内容が異なること。  
別トランザクションでUPDATEすることによって起こる。  

#### phantom-read  

トランザクション開始時に読み込んだレコード数と、  
別トランザクションでコミット後に再度読み込んだレコード数が異なること。  
別トランザクションでINSERT, DELETEすることによって起こる。  

### 参考

<https://gihyo.jp/dev/serial/01/db-academy/000203>  
<https://ja.wikipedia.org/wiki/食事する哲学者の問題>  
<https://engineering.mercari.com/blog/entry/2017-12-18-deadlock/>  
<https://tech.andpad.co.jp/entry/2020/07/13/123720>  

